## Algorithms

(document generated by Cursor AI)

This file documents only:
- Pattern matching
- Reverse pattern matching
- Type checking for variable binding and function calling

### Pattern matching (runtime)

Compares resolved `(condSort, condValue)` against a `pattern`, possibly extending the `frame`.

- **Exact** `(exact e)`: match iff resolved value equals `e` syntactically.
- **Variable** `x`: bind `x = condValue` at `condSort`.
- **Structural** `(f x)`: match only a function call; recursively match head and argument.

Pseudocode (see `matchPattern` in `el/match.go`):

```text
matchPattern(frame, condSort, condValue, pattern):
  switch pattern:
    Exact(e):
      (_, _, v) := resolve(e)
      return frame, string(v) == string(condValue)
    Term(name):
      frame' := frame.set(name, condSort, condValue)
      return frame', true
    FunctionCall(cmdPat, argPat):
      if condValue is FunctionCall(cmdVal, argVal):
        frame1, ok := matchPattern(frame, sort(cmdVal), val(cmdVal), cmdPat)
        if not ok: return frame, false
        return matchPattern(frame1, sort(argVal), val(argVal), argPat)
      return frame, false
    default:
      return frame, false
```

### Reverse pattern matching (for typing)

Propagates sorts implied by a pattern into the frame without needing a concrete scrutinee value.

- **Exact**: resolve inner expr; no bindings.
- **Variable**: bind variable to itself at the scrutinee sort.
- **Structural** `(f x)`: require `f`’s sort parent to be an arrow `A -> B` and `B` to be compatible with the scrutinee’s parent sort; then recurse on `x` under sort `A`.

Pseudocode (see `reverseMatchPattern` in `el/match.go`):

```text
reverseMatchPattern(frame, condSort, pattern):
  switch pattern:
    Exact(e):
      resolve(e); return frame
    Term(name):
      return frame.set(name, condSort, name)
    FunctionCall(cmdPat, argPat):
      (_, cmdSort, _) := resolve(cmdPat)
      require parent(cmdSort) = Arrow(A, B)
      require SubTypeOf(B, parent(condSort))
      return reverseMatchPattern(frame, Term(A, string(argPat)), argPat)
    default:
      return frame
```

### Type checking

#### Function calling

`typeCheckFunctionCall(cmdSort, argSort) -> (resSort, ok)` (see `el/type.go`):
- Check `parent(cmdSort)` is `Arrow(A, B)`.
- Check `TermOf(argSort, A)`.
- Return `(B, true)` on success; otherwise `(nil, false)`.

#### Variable binding

`typeCheckBinding(parentSort, name, expr) -> ok` (see `el/type.go`):
- **undef**: always ok.
- **lambda**: require `parentSort = Arrow(A, B)`; extend frame with `name : parentSort` and `param : A`; check `body` against `B`.
- **match**: resolve scrutinee to `condSort`; for each case, extend frame with `reverseMatchPattern(frame, condSort, pattern)` and check branch against `parentSort`; finally check `final` against `parentSort`.
- **other**: resolve `expr` to `sort`; require `TermOf(sort, parentSort)`.

Notes:
- Reverse matching is permissive and only prepares environments for branch checks.
- Structural patterns must denote functions whose outputs are compatible with the scrutinee sort.



