inh Bool : Type0
inh true : Bool
inh false : Bool

-- assume the inductive type Nat exists with induction Nac_rec
-- for CIC systems like lean
-- inductive type will be checked for positive recurrent and
-- induction will be automatically generated

inh Nat : Type0
inh zero : Nat
inh succ : hom Nat -> Nat

inh Nat_rec : hom
  (P : hom Nat -> Type0)
  (base_case: (P zero))
  (ind_case: hom (m : Nat) (P_m: (P m)) -> (P (succ m)))
  (n: Nat) -> (P n)

-- assume (Vec n T) exists for all type (T: Type0)
inh Vec : hom Nat Type0 -> Type0
inh nil : hom (T: Type0) -> (Vec zero T)
inh push : hom (n: Nat) (T: Type0) (v: (Vec n T)) (x: T) -> (Vec (succ n) T)

-- some example code

-- for let syntax, instead of `let x (: typeX) := y in z`
-- we use new line or semicolon ; instead of in
-- `let x = y in z`
-- let syntax without type annotation is basically just syntactic sugar for
-- ((Î» x z) y)
-- which is just name binding
let one := (succ zero)
let two := (succ one)

-- `let x: typeX := y in z`
-- let syntax with type annotation will be type-checked by the kernel
let pure: hom Nat -> (Vec one Nat) := lam x =>
  (push zero Nat (nil Nat) x)
let pure_two: (Vec one Nat) := (pure two)

-- pattern matching is just induction
let is_zero : hom Nat -> Bool := lam n =>
  (
    Nat_rec
    (lam _ => Bool)     --  for every n, the return type is Bool
    true                --  case zero
    (lam m _ => false)  --  case succ
    n                   --  apply inductive statement on n
  )

-- TODO adding these 4 lines breaks type checker
-- let x : Nat := (is_zero zero)
-- let y : Nat := (is_zero one)
-- let z : Nat := (is_zero two)

Type0

